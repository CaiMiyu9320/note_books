# 运算符

## 算术运算符

假设变量 A 的值为 10，变量 B 的值为 20，则:

| 运算符 | 描述                                   | 实例            |
|:---:|:------------------------------------:|:-------------:|
| +   | 把两个操作数相加                             |               |
| -   | 从第一个操作数中减去第二个操作数                     | A - B 将得到 -10 |
| *   | 把两个操作数相乘 | A * B 将得到 200 |
| /   | 分子除以分母                               | B / A 将得到 2   |
| %   | 取模运算符，整除后的余数                         | B % A 将得到 0   |
| ++  | 自增运算符，整数值增加 1                        | A++ 将得到 11    |
| --  | 自减运算符，整数值减少 1                        | A-- 将得到 9     |

```C#
    c = a++: //先将 a 赋值给 c，再对 a 进行自增运算。
    c = ++a: //先将 a 进行自增运算，再将 a 赋值给 c 。
    c = a--: //先将 a 赋值给 c，再对 a 进行自减运算。
    c = --a: //先将 a 进行自减运算，再将 a 赋值给 c 。
```

## 关系运算符

| 运算符 | 描述                             | 实例           |
|:---:|:------------------------------:|:------------:|
| ==  | 检查两个操作数的值是否相等，如果相等则条件为真        | (A == B) 不为真 |
| !=  | 检查两个操作数的值是否相等，如果不相等则条件为真       | (A != B) 为真  |
| <   | 检查左操作数的值是否大于右操作数的值，如果是则条件为真    | (A > B) 不为真  |
| >   | 检查左操作数的值是否小于右操作数的值，如果是则条件为真    | (A < B) 为真   |
| >=  | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真 | (A >= B) 不为真 |
| <=  | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真 | (A <= B) 为真  |

## 逻辑运算符

下表显示了 C# 支持的所有逻辑运算符。假设变量 A 为布尔值 true，变量 B 为布尔值 false，则：

| 运算符 | 描述                                       | 实例                             |
|:---:|:----------------------------------------:|:------------------------------:|
| &&  | 称为逻辑与运算符。如果两个操作数都非零，则条件为真                | (A && B) 为假                    |
|     | \|                                       | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真 |
| !   | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假 | !(A && B) 为真                   |

## 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p   | q   | p&q | p\|q | p^q |
|:---:|:---:|:---:|:----:|:---:|
| 0   | 0   | 0   | 0    | 0   |
| 0   | 1   | 0   | 1    | 1   |
| 1   | 1   | 1   | 1    | 0   |
| 1   | 0   | 0   | 1    | 1   |

下表列出了 C# 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13[^1]，则

| 运算符 | 描述                                          | 实例                                         |
|:---:|:-------------------------------------------:|:------------------------------------------:|
| &   | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中           | (A & B) 将得到 12，即为 0000 1100                |
|     |                                             | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。            |
| ^   | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中 | (A ^ B) 将得到 49，即为 0011 0001                |
| ~   | 按位取反运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0，包括符号位    | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<  | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数                | A << 2 将得到 240，即为 1111 0000                |
| >>  | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数                | A >> 2 将得到 15，即为 0000 1111                 |



## 赋值运算符

| 运算符    | 描述                               | 实例                        |
|:------:|:--------------------------------:|:-------------------------:|
| +      | 简单的赋值运算符，把右边操作数的值赋给左边操作数         | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A      |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A      |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A      |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A      |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数        | C %= A 相当于 C = C % A      |
| <<=    | 左移且赋值运算符                         | C <<= 2 等同于 C = C << 2    |
| >>=    | 右移且赋值运算符                         | C >>= 2 等同于 C = C >> 2    |
| &=     | 按位与且赋值运算符                        | C &= 2 等同于 C = C & 2      |
| ^=     | 按位异或且赋值运算符                       | C ^= 2 等同于 C = C ^ 2      |
| ...... | ......                           | ......                    |

## 其他运算符

> **优先级简易概括**：有括号先括号，后乘除在加减，然后位移再关系，逻辑完后条件，最后一个逗号 ,

> **注意：**
> 由于括号可以改变运算符优先级，所以在实际应用中建议尽可能使用括号来明确运算顺序，提高代码的可读性和准确性。



[^1]: 假设如果A=60，且B=13，现在以二进制格式表示，它们如下所示：A=0011,1100,B=0000,1101
